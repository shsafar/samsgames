<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Double Bubble Words Game</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
      background: #0a0e1a;
      color: #f5f5f5;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      touch-action: manipulation;
    }

    .game-wrapper {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    /* Mobile-optimized top bar - LARGER */
    .top-bar {
      background: rgba(0,0,0,0.6);
      padding: 18px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .title-bar {
      margin-bottom: 14px;
    }

    .title-bar h1 {
      font-size: 2.4rem;
      font-weight: bold;
      color: #fff;
      margin-bottom: 10px;
    }

    .title-bar .subline {
      font-size: 1.3rem;
      color: rgba(255,255,255,0.85);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      align-items: center;
      justify-content: space-between;
    }

    .controls > div {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .controls label {
      font-size: 1.3rem;
      color: rgba(255,255,255,0.9);
      font-weight: 600;
    }

    .controls select {
      background: rgba(255,255,255,0.15);
      border: 2px solid rgba(255,255,255,0.4);
      color: #fff;
      padding: 12px 18px;
      border-radius: 8px;
      font-size: 1.3rem;
      font-weight: 600;
    }

    .controls button {
      background: #28a8ff;
      border: none;
      padding: 14px 24px;
      border-radius: 10px;
      color: #fff;
      font-weight: bold;
      font-size: 1.3rem;
      cursor: pointer;
    }

    .controls button:active {
      background: #1b88d0;
    }

    /* Mobile-optimized score board - LARGER */
    .score-board {
      background: rgba(0,0,0,0.5);
      padding: 18px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 14px;
      font-size: 1.4rem;
      border-bottom: 2px solid rgba(255,255,255,0.15);
      font-weight: 600;
    }

    .score-board span {
      font-weight: bold;
      color: #4fc3f7;
    }

    .score-group {
      display: flex;
      gap: 24px;
      align-items: center;
    }

    .target-display {
      font-size: 1.4rem;
      background: rgba(255,228,91,0.2);
      padding: 10px 20px;
      border-radius: 16px;
      border: 2px solid rgba(255,228,91,0.4);
    }

    .target-display span {
      font-weight: bold;
      color: #ffe45b;
      font-size: 1.6rem;
    }

    .current-pick {
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    #pick-letters {
      display: inline-block;
      min-width: 40px;
      padding: 6px 14px;
      border-radius: 18px;
      background: linear-gradient(135deg, #7b2cbf, #9d4edd);
      border: 2px solid #c77dff;
      text-align: center;
      font-weight: bold;
      font-size: 1.3rem;
      color: #fff;
      letter-spacing: 1px;
    }

    /* Fullscreen game area */
    .game-area {
      position: relative;
      flex: 1;
      width: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #8de5e5, #4db8b8);
    }

    .theme-default {
      background: radial-gradient(circle at top, #8de5e5, #4db8b8);
    }
    .theme-social {
      background: radial-gradient(circle at top, #ffd1dc, #ffb3c1);
    }
    .theme-scientific {
      background: radial-gradient(circle at top, #b8e0ff, #7dc8ff);
    }
    .theme-animals {
      background: radial-gradient(circle at top, #c8e6c9, #81c784);
    }

    .overlay-message {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 1.4rem;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .overlay-message.visible {
      opacity: 1;
    }

    .overlay-message small {
      font-size: 0.9rem;
      margin-top: 6px;
      opacity: 0.85;
    }

    .bubble {
      position: absolute;
      width: 90px;
      height: 90px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffffff, #82d4ff);
      box-shadow: 0 0 15px rgba(130,212,255,0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2.2rem;
      font-weight: bold;
      color: #00324f;
      border: 3px solid rgba(255,255,255,0.75);
      cursor: pointer;
      user-select: none;
      transition: transform 0.1s ease, box-shadow 0.1s ease, border-color 0.1s ease;
    }

    .bubble.selected {
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(255,255,255,1);
      border-color: #ffe45b;
    }

    /* Burst animation */
    .bubble.burst {
      animation: bubbleBurst 0.25s forwards;
    }

    @keyframes bubbleBurst {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      100% {
        transform: scale(1.6);
        opacity: 0;
      }
    }

    .bottom-panels {
      display: flex;
      gap: 16px;
      padding: 20px;
      font-size: 1.2rem;
      background: rgba(0,0,0,0.5);
      border-top: 2px solid rgba(255,255,255,0.15);
      overflow-x: auto;
      flex-shrink: 0;
    }

    .panel {
      background: rgba(27, 29, 38, 0.8);
      border-radius: 12px;
      padding: 16px;
      border: 2px solid #3e4458;
      overflow: hidden;
      flex: 1;
      min-width: 200px;
    }

    .panel h3 {
      font-size: 1.3rem;
      margin-bottom: 12px;
      opacity: 0.95;
      font-weight: 700;
      color: #fff;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      max-height: 150px;
      overflow-y: auto;
    }

    .chip {
      padding: 10px 18px;
      border-radius: 999px;
      background: #29324c;
      color: #f5f5f5;
      font-size: 1.15rem;
      border: 2px solid #3c4a6b;
      white-space: nowrap;
      min-height: 44px;
      display: flex;
      align-items: center;
      font-weight: 600;
    }

    .chip.word {
      background: #21c178;
      border-color: #23e18b;
      color: #022516;
      font-weight: bold;
    }

    .log {
      font-size: 1.05rem;
      max-height: 140px;
      overflow-y: auto;
      line-height: 1.5;
    }

    .log-entry {
      opacity: 0.9;
      margin-bottom: 6px;
    }

    .log-entry + .log-entry {
      margin-top: 4px;
    }

    /* Tutorial overlay - hidden in daily mode */
    .tutorial-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .tutorial-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .tutorial-box {
      background: #1b1d26;
      border-radius: 16px;
      padding: 24px;
      max-width: 90%;
      width: 500px;
      border: 2px solid #3a405b;
      box-shadow: 0 0 30px rgba(0,0,0,0.9);
    }

    .tutorial-box h2 {
      font-size: 1.8rem;
      margin-bottom: 16px;
      font-weight: bold;
    }

    .tutorial-box p {
      font-size: 1.15rem;
      opacity: 0.95;
      margin-bottom: 12px;
      line-height: 1.5;
    }

    .tutorial-box ul {
      margin: 12px 0 16px;
      padding-left: 24px;
      font-size: 1.1rem;
      opacity: 0.95;
      line-height: 1.6;
    }

    .tutorial-box li + li {
      margin-top: 10px;
    }

    .tutorial-footnote {
      font-size: 1rem;
      opacity: 0.8;
      margin-bottom: 16px;
      line-height: 1.5;
    }

    .tutorial-actions {
      display: flex;
      justify-content: flex-end;
    }

    .tutorial-btn {
      background: #28a8ff;
      border: none;
      padding: 14px 24px;
      border-radius: 10px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.1rem;
    }

    .tutorial-btn:hover {
      background: #1b88d0;
    }
  </style>
</head>
<body>
<div class="game-wrapper">

  <div class="top-bar">
    <div class="title-bar">
      <h1>Double Bubble Words Game</h1>
      <div class="subline">Tap two bubbles to create fragments. Fragments auto-merge into words.</div>
    </div>

    <div class="controls">
      <div>
        <label for="mode-select">Mode:</label>
        <select id="mode-select">
          <option value="relax">Relax</option>
          <option value="timed">Timed (60s)</option>
          <option value="fragments">Fragment Cap (12)</option>
        </select>
      </div>
      <div>
        <label for="difficulty-select">Difficulty:</label>
        <select id="difficulty-select">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </div>
      <div>
        <label for="dict-select">Theme:</label>
        <select id="dict-select">
          <option value="default">Default</option>
          <option value="social">Social Words</option>
          <option value="scientific">Scientific Words</option>
          <option value="animals">Animals</option>
        </select>
      </div>
      <button id="btn-start">Start</button>
      <button id="btn-pause">Pause</button>
      <button id="btn-restart">Restart</button>
    </div>
  </div>

  <div class="score-board">
    <div class="score-group">
      <div>Score: <span id="score">0</span></div>
      <div>Best: <span id="best-score">0</span></div>
      <div>Words: <span id="word-count">0</span></div>
      <div>Fragments: <span id="fragment-count">0</span></div>
    </div>
    <div class="target-display">
      Target: <span id="target-word">—</span>
    </div>
    <div class="current-pick">
      Pick:
      <span id="pick-letters">—</span>
    </div>
    <div class="timer">Time: <span id="time-left">∞</span></div>
  </div>

  <div id="game-area" class="game-area theme-default">
    <div id="overlay" class="overlay-message">
      <div id="overlay-text">Game Over</div>
      <small>Press Restart to play again.</small>
    </div>
  </div>

  <div class="bottom-panels">
    <div class="panel">
      <h3>Fragments</h3>
      <div id="fragments" class="chips"></div>
    </div>
    <div class="panel">
      <h3>Words Formed</h3>
      <div id="words" class="chips"></div>
    </div>
    <div class="panel">
      <h3>Log</h3>
      <div id="log" class="log"></div>
    </div>
  </div>
</div>

<!-- Tutorial overlay -->
<div id="tutorial-overlay" class="tutorial-overlay">
  <div class="tutorial-box">
    <h2>How to Play Word Drift</h2>
    <p>Quick basics so you can start playing in seconds:</p>
    <ul>
      <li><strong>Tap two bubbles</strong> to pop them into a letter fragment (like <em>AT</em> or <em>TO</em>).</li>
      <li>Fragments <strong>auto-merge into real words</strong> from the theme dictionary for points.</li>
      <li>Watch the <strong>TARGET word</strong> and modes at the top – forming the target gives a bonus.</li>
    </ul>
    <p class="tutorial-footnote">
      You can change <strong>Mode</strong>, <strong>Difficulty</strong>, and <strong>Theme</strong> anytime.  
      This tutorial only shows once on this device.
    </p>
    <div class="tutorial-actions">
      <button id="tutorial-close" class="tutorial-btn">Got it, let’s play</button>
    </div>
  </div>
</div>

<script>
  const gameArea = document.getElementById('game-area');
  const overlay = document.getElementById('overlay');
  const overlayText = document.getElementById('overlay-text');

  const scoreEl = document.getElementById('score');
  const bestScoreEl = document.getElementById('best-score');
  const wordCountEl = document.getElementById('word-count');
  const fragmentCountEl = document.getElementById('fragment-count');
  const fragmentsEl = document.getElementById('fragments');
  const wordsEl = document.getElementById('words');
  const logEl = document.getElementById('log');
  const timeLeftEl = document.getElementById('time-left');
  const targetWordEl = document.getElementById('target-word');
  const pickLettersEl = document.getElementById('pick-letters');

  const btnStart = document.getElementById('btn-start');
  const btnPause = document.getElementById('btn-pause');
  const btnRestart = document.getElementById('btn-restart');
  const modeSelect = document.getElementById('mode-select');
  const dictSelect = document.getElementById('dict-select');
  const difficultySelect = document.getElementById('difficulty-select');

  const tutorialOverlay = document.getElementById('tutorial-overlay');
  const tutorialClose = document.getElementById('tutorial-close');

  const LETTERS = "AABCDEEFGHIIJKLMNOOPQRSTUUVWXYZ";

  const DICTIONARIES = {
    default: [
      // 2-letter words - All 107 valid Scrabble/English words
      "AA","AB","AD","AE","AG","AH","AI","AL","AM","AN","AR","AS","AT","AW","AX","AY",
      "BA","BE","BI","BO","BY",
      "DA","DE","DO",
      "ED","EF","EH","EL","EM","EN","ER","ES","ET","EX",
      "FA","FE",
      "GO","GU",
      "HA","HE","HI","HM","HO",
      "ID","IF","IN","IS","IT",
      "JO",
      "KA","KI",
      "LA","LI","LO",
      "MA","ME","MI","MM","MO","MU","MY",
      "NA","NE","NO","NU",
      "OD","OE","OF","OH","OI","OK","OM","ON","OP","OR","OS","OW","OX","OY",
      "PA","PE","PI","PO",
      "QI",
      "RE",
      "SH","SI","SO",
      "TA","TI","TO",
      "UG","UH","UM","UN","UP","UR","US","UT",
      "WE","WO",
      "XI","XU",
      "YA","YE","YO",
      "ZA","ZO",
      // 4-letter words
      "ABLE","BACK","BALL","BANK","BASE","BEAR","BEAT","BEEN","BELL","BEST","BIRD","BLOW","BLUE","BOAT",
      "BODY","BOOK","BORN","BOTH","BOWL","BUSY","CALL","CAME","CAMP","CARD","CARE","CASE","CAST","CELL",
      "CITY","CLUB","COAL","COAT","COLD","COME","COOK","COOL","COPY","COST","DARK","DATA","DATE","DEAL",
      "DEAR","DEEP","DESK","DIAL","DICE","DIET","DISH","DOES","DONE","DOOR","DOWN","DRAW","DREW","DROP",
      "DRUG","DUAL","DUCK","DUTY","EACH","EARN","EASE","EAST","EASY","EDGE","ELSE","EVEN","EVER","FACE",
      "FACT","FAIL","FAIR","FALL","FARM","FAST","FEAR","FEED","FEEL","FEET","FELL","FELT","FILE","FILL",
      "FILM","FIND","FINE","FIRE","FIRM","FISH","FIVE","FLAT","FLOW","FOLK","FOOD","FOOT","FORD","FORK",
      "FORM","FORT","FOUR","FREE","FROM","FUEL","FULL","FUND","GAIN","GAME","GATE","GAVE","GEAR","GIFT",
      "GIRL","GIVE","GLAD","GOAL","GOES","GOLD","GOLF","GONE","GOOD","GRAY","GREW","GROW","GULF","HAIR",
      "HALF","HALL","HAND","HANG","HARD","HARM","HATE","HAVE","HEAD","HEAR","HEAT","HELD","HELL","HELP"
    ],
    social: [
      // 2-letter words - Social context
      "HI","WE","US","BE","ME","MY","MA","PA","OK","NO","SO","OH","AH","YO","HE","AM","AS","AT","BY","DO",
      "GO","IF","IN","IS","IT","OF","ON","OR","TO","UP","AN","HA","HO","LA","LO","RE","UN","YE","YA","UM",
      // 4-letter words
      "ABLE","ALLY","BAND","BEAM","BOND","CALL","CALM","CARE","CHAT","CHUM","COZY","DATE","DEAR","DINE",
      "EMIT","FACE","FAME","FEEL","FOLK","FOND","FREE","FRIEND","GATHER","GIFT","GIVE","GLAD","GREET",
      "GROUP","GUEST","HAND","HAPPY","HELLO","HELP","HOME","HOPE","HOST","HUGS","IDEA","INVITE","JOIN",
      "KIND","KISS","KNOW","LAUGH","LIKE","LINK","LISTEN","LIVE","LOVE","MARRY","MATE","MEET","MINGLE",
      "MOOD","NAME","NEED","NICE","PALS","PARTY","PEACE","PEOPLE","PLEASE","POLITE","PRAISE","SHARE",
      "SHAKE","SHOUT","SIGN","SMILE","SPEAK","STAY","SWEET","TALK","TEAM","THANK","THINK","TOAST","TONE",
      "TRUST","TURN","UNITE","USAGE","VISIT","VOICE","VOTE","WAIT","WALK","WANT","WARM","WAVE","WELCOME",
      "WINK","WISH","WITH","WORD","WORK","WRITE","YOGA"
    ],
    scientific: [
      // 2-letter words - Scientific/Technical
      "PI","OM","MU","NU","OX","AX","ID","AG","AL","AR","AS","AT","BE","BY","DO","EL","EM","EN","ER","ET",
      "GO","HE","IF","IN","IO","IS","IT","LA","LI","NO","OF","ON","OR","OS","OW","PE","PO","RE","SI","SO",
      // 4-letter words
      "ACID","ATOM","BASE","BEAM","BOIL","BOND","CELL","CLONE","CODE","CORE","DATA","DECAY","DOSE","EARTH",
      "ENERGY","ENZYME","FIELD","FLUX","FORCE","FOSSIL","GENE","GERM","GRAPH","HEAT","HELIX","IRON","LASER",
      "LAVA","LENS","LIGHT","LIQUID","MASS","MATTER","METAL","METER","MICRO","MOLD","MOON","NERVE","NEUTRON",
      "NOVA","NUCLEUS","ORBIT","ORGAN","OXIDE","OZONE","PHASE","PLASMA","POLE","POWER","PROBE","PROTON",
      "QUARK","RADAR","RATIO","REACT","ROCK","SALT","SCALE","SENSOR","SERIES","SHELL","SOLAR","SOUND",
      "SPACE","SPEED","SPIN","STAR","STEAM","STRAIN","SYSTEM","TEST","THEORY","TIDE","TIME","TISSUE",
      "TOXIN","TRACE","VACUUM","VAPOR","VIRUS","VOLT","WAVE","WEIGHT","WIRE","ZERO","ZONE"
    ],
    animals: [
      // 2-letter words - Animals
      "OX","YO","AS","AT","BE","BY","DO","GO","HE","IF","IN","IS","IT","MA","ME","MY","NO","OF","ON","OR",
      "PA","SO","TO","UP","US","WE","AN","AM","AH","AW","HA","HI","HO","LA","LO","OH","UM","UN","YA","YE",
      // 4-letter words
      "BEAR","BIRD","BOAR","BUCK","BULL","CALF","CAMEL","CHICK","CLAM","COLT","CRAB","CRANE","CROW","DEER",
      "DODO","DOVE","DUCK","EAGLE","FAWN","FISH","FLEA","FOWL","FROG","GNAT","GOAT","GOOSE","GULL","HARE",
      "HAWK","HERON","HORSE","HOUND","IBEX","JOEY","KITE","KOALA","LAMB","LARK","LION","LIZARD","LOON",
      "LYNX","MINK","MOLE","MOOSE","MOTH","MOUSE","MULE","NEWT","PANDA","PONY","PUMA","QUAIL","RABBIT",
      "RAVEN","ROBIN","SEAL","SHARK","SHEEP","SKUNK","SLOTH","SNAIL","SNAKE","SPARROW","SPIDER","SQUID",
      "STAG","STORK","SWAN","TIGER","TOAD","TROUT","TURKEY","VIPER","VOLE","WASP","WHALE","WOLF","WORM",
      "ZEBRA"
    ]
  };

  const DIFFICULTY_SETTINGS = {
    easy:   { speedMin: 0.6, speedMax: 1.2, spawnChance: 0.55, bubbleCap: 10 },
    normal: { speedMin: 0.8, speedMax: 1.6, spawnChance: 0.8,  bubbleCap: 12 },
    hard:   { speedMin: 1.2, speedMax: 2.0, spawnChance: 1.0,  bubbleCap: 14 }
  };

  let currentDifficulty = 'normal';
  let WORD_DICTIONARY = DICTIONARIES.default.slice();
  let currentTheme = 'default';
  let targetWord = null;
  let targetWordPairs = []; // Required 2-letter pairs for target word
  let foundTargetPairs = new Set(); // Track which pairs have been found
  let shuffledTargetPool = []; // Shuffled pool of target words
  let targetWordIndex = 0; // Current index in shuffled pool

  // Shuffle array using seededRandom for consistency in daily mode
  function shuffleArray(arr) {
    const shuffled = [...arr];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(seededRandom() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  // Initialize shuffled target word pool
  function initTargetWordPool() {
    const list = DICTIONARIES[currentTheme] || [];
    const candidates = list.filter(w => w.length >= 4);
    const pool = candidates.length > 0 ? candidates : list;
    shuffledTargetPool = shuffleArray(pool);
    targetWordIndex = 0;
  }

  const FRAGMENT_LIMIT = 12;
  const TIMED_MODE_SECONDS = 60;

  let bubbles = [];
  let bubbleIdCounter = 0;
  let gameInterval = null;
  let spawnInterval = null;
  let timerInterval = null;
  let running = false;
  let gameOverFlag = false;

  let selectedBubbles = [];
  let fragments = [];
  let words = [];
  let score = 0;
  let bestScore = 0;
  let timeLeft = Infinity;

  // DAILY MODE INTEGRATION
  window.dailyMode = false;
  let dailySeed = null;
  let seededRandom = Math.random; // Default to Math.random

  // Seeded random number generator (LCG algorithm)
  function createSeededRandom(seed) {
    let state = seed % 2147483647;
    if (state <= 0) state += 2147483646;

    return function() {
      state = (state * 16807) % 2147483647;
      return (state - 1) / 2147483646;
    };
  }

  // Set seed for daily mode
  window.setSeed = function(seed) {
    dailySeed = seed;
    seededRandom = createSeededRandom(seed);
    console.log("✅ Seed set for daily mode:", seed);
  };

  // Start daily game (called from Swift)
  window.startDailyGame = function() {
    window.dailyMode = true;
    console.log("✅ Starting daily game mode");

    // Set to fragment cap mode with 12 fragments
    try {
      modeSelect.value = 'fragments';
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
    } catch (e) {
      console.log("⚠️ Error setting mode:", e);
    }

    // Start the game automatically (MUST happen)
    console.log("✅ Calling restartGame()");
    restartGame();
    logEl.innerHTML = "";  // Clear duplicate log entry from restartGame
    console.log("✅ Calling startGame()");
    startGame();
    console.log("✅ Game should be running now");
  };

  // Notify Swift when game completes
  function notifyGameComplete() {
    if (window.dailyMode && window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCompleted) {
      window.webkit.messageHandlers.gameCompleted.postMessage({
        score: score
      });
      console.log("✅ Daily puzzle completed - notified Swift with score:", score);
    }
  }

  // SOUND
  let audioCtx = null;
  function initAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  function playBeep(freq, duration, type = "sine", volume = 0.2) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = volume;

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    osc.start(now);
    osc.stop(now + duration);
  }

  function playPopSound() {
    playBeep(600, 0.07, "square", 0.15);
  }

  function playWordSound() {
    playBeep(800, 0.09, "triangle", 0.2);
    setTimeout(() => playBeep(1200, 0.09, "triangle", 0.2), 110);
  }

  function log(message) {
    const div = document.createElement('div');
    div.className = 'log-entry';
    div.textContent = message;
    logEl.prepend(div);
    const maxLines = 15;
    while (logEl.children.length > maxLines) {
      logEl.removeChild(logEl.lastChild);
    }
  }

  function randomLetter() {
    return LETTERS[Math.floor(seededRandom() * LETTERS.length)];
  }

  // High score
  function loadBestScore() {
    try {
      const stored = localStorage.getItem('wordDriftHighScore');
      bestScore = stored !== null ? (parseInt(stored, 10) || 0) : 0;
    } catch (e) {
      bestScore = 0;
    }
    bestScoreEl.textContent = bestScore.toString();
  }

  function updateBestScore() {
    if (score > bestScore) {
      bestScore = score;
      bestScoreEl.textContent = bestScore.toString();
      try {
        localStorage.setItem('wordDriftHighScore', String(bestScore));
      } catch (e) {}
      log("New high score! " + bestScore);
    }
  }

  // Target word
  function pickNewTargetWord() {
    // Initialize pool if empty or exhausted
    if (shuffledTargetPool.length === 0 || targetWordIndex >= shuffledTargetPool.length) {
      initTargetWordPool();
    }

    if (shuffledTargetPool.length === 0) {
      targetWord = null;
      targetWordEl.textContent = "—";
      targetWordPairs = [];
      foundTargetPairs.clear();
      return;
    }

    // Pick next word from shuffled pool
    targetWord = shuffledTargetPool[targetWordIndex++];

    // Calculate consecutive non-overlapping 2-letter pairs
    targetWordPairs = [];
    foundTargetPairs.clear();
    for (let i = 0; i < targetWord.length - 1; i += 2) {
      const pair = targetWord.substring(i, i + 2);
      targetWordPairs.push(pair);
    }

    updateTargetWordDisplay();
    log("New target word: " + targetWord + " (pairs: " + targetWordPairs.join(", ") + ")");
  }

  // Update target word display with highlighting
  function updateTargetWordDisplay() {
    if (!targetWord) {
      targetWordEl.textContent = "—";
      return;
    }

    // Build HTML with highlighted pairs
    let html = '';
    for (let i = 0; i < targetWord.length; i++) {
      const pairIndex = Math.floor(i / 2);
      const pair = targetWordPairs[pairIndex];
      const isFound = foundTargetPairs.has(pair);

      if (i % 2 === 0) {
        // Start of a pair
        html += `<span style="color: ${isFound ? '#4ade80' : 'inherit'}; font-weight: ${isFound ? 'bold' : 'normal'}">`;
      }
      html += targetWord[i];
      if (i % 2 === 1) {
        // End of a pair
        html += '</span>';
      }
    }

    targetWordEl.innerHTML = html;
  }

  // Staging display
  function updatePickDisplay() {
    if (selectedBubbles.length === 0) {
      pickLettersEl.textContent = "—";
      return;
    }
    const txt = selectedBubbles.map(b => b.letter).join('');
    pickLettersEl.textContent = txt;
  }

  function spawnBubble() {
    const rect = gameArea.getBoundingClientRect();
    const bubbleSize = 58;
    const settings = DIFFICULTY_SETTINGS[currentDifficulty];

    const x = seededRandom() * (rect.width - bubbleSize);
    const y = rect.height;
    const speed = settings.speedMin + seededRandom() * (settings.speedMax - settings.speedMin);

    const letter = randomLetter();
    const id = bubbleIdCounter++;

    const el = document.createElement('div');
    el.className = 'bubble';
    el.textContent = letter;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.dataset.id = id;
    el.dataset.letter = letter;

    el.addEventListener('click', () => onBubbleClick(id));

    gameArea.appendChild(el);

    bubbles.push({ id, x, y, speed, letter, el });
  }

  function onBubbleClick(id) {
    if (!running || gameOverFlag) return;
    initAudio();

    const bubble = bubbles.find(b => b.id === id);
    if (!bubble) return;

    const alreadySelected = selectedBubbles.find(b => b.id === id);

    if (alreadySelected) {
      bubble.el.classList.remove('selected');
      selectedBubbles = selectedBubbles.filter(b => b.id !== id);
      updatePickDisplay();
      return;
    }

    if (selectedBubbles.length >= 2) {
      selectedBubbles.forEach(b => b.el.classList.remove('selected'));
      selectedBubbles = [];
    }

    bubble.el.classList.add('selected');
    selectedBubbles.push(bubble);
    updatePickDisplay();

    if (selectedBubbles.length === 2) {
      createFragmentFromSelection();
    }
  }

  // Helper: burst + remove both visually and from list
  function burstAndRemoveBubble(bubble) {
    if (!bubble || !bubble.el) return;
    const el = bubble.el;

    // stop gameLoop from moving it
    bubbles = bubbles.filter(x => x.id !== bubble.id);

    el.classList.remove('selected');
    el.classList.add('burst');

    el.addEventListener('animationend', () => {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, { once: true });
  }

  // Non-animated removal (for off-screen, restart, etc.)
  function removeBubblePlain(id) {
    const index = bubbles.findIndex(b => b.id === id);
    if (index === -1) return;
    const bubble = bubbles[index];
    bubbles.splice(index, 1);
    if (bubble.el && bubble.el.parentNode) {
      bubble.el.parentNode.removeChild(bubble.el);
    }
  }

  function createFragmentFromSelection() {
    if (selectedBubbles.length !== 2) return;
    const [b1, b2] = selectedBubbles;
    const fragmentText = (b1.letter + b2.letter).toUpperCase();

    burstAndRemoveBubble(b1);
    burstAndRemoveBubble(b2);

    selectedBubbles = [];
    updatePickDisplay();

    addFragment(fragmentText);
    playPopSound();
  }

  function addFragment(text) {
    const id = Date.now() + ":" + Math.random().toString(16).slice(2);
    fragments.push({ id, text });

    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent = text;
    chip.dataset.id = id;
    fragmentsEl.appendChild(chip);

    fragmentCountEl.textContent = fragments.length.toString();
    log("Fragment: " + text);

    const isDictWord = WORD_DICTIONARY.includes(text);
    const isPrefixOfTarget =
      !!(targetWord &&
         targetWord.length > text.length &&
         targetWord.startsWith(text));

    // If it's a dictionary word but also a strict prefix of target,
    // keep as fragment so it can grow into the target word.
    if (isDictWord && !isPrefixOfTarget) {
      formWordFromFragments([id], text);
    } else {
      tryMergeFragments();
    }

    if (modeSelect.value === 'fragments' && fragments.length > FRAGMENT_LIMIT) {
      triggerGameOver("Too many fragments (> " + FRAGMENT_LIMIT + ")");
    }
  }

  function formWordFromFragments(fragmentIds, wordText) {
    fragmentIds.forEach(fid => {
      const idx = fragments.findIndex(f => f.id === fid);
      if (idx !== -1) fragments.splice(idx, 1);

      const chip = fragmentsEl.querySelector(`.chip[data-id="${fid}"]`);
      if (chip) chip.remove();
    });

    fragmentCountEl.textContent = fragments.length.toString();

    const id = Date.now() + ":" + Math.random().toString(16).slice(2);
    words.push({ id, text: wordText });

    const chip = document.createElement('div');
    chip.className = 'chip word';
    chip.textContent = wordText;
    chip.dataset.id = id;
    wordsEl.appendChild(chip);

    const base = 10;
    const lenBonus = Math.max(0, wordText.length - 2) * 5;
    let newScore = base + lenBonus;

    // Check if this is a 2-letter word that's part of the target word pairs
    if (targetWord && wordText.length === 2 && targetWordPairs.includes(wordText)) {
      if (!foundTargetPairs.has(wordText)) {
        foundTargetPairs.add(wordText);
        log(`Found target pair: "${wordText}" (${foundTargetPairs.size}/${targetWordPairs.length})`);
        updateTargetWordDisplay();

        // Check if all pairs are found
        if (foundTargetPairs.size === targetWordPairs.length) {
          const bonus = 30;
          newScore += bonus;
          log(`All target pairs found! Auto-completing "${targetWord}" (+${bonus} bonus)`);

          // Add the target word as a completed word
          const targetId = Date.now() + ":" + Math.random().toString(16).slice(2);
          words.push({ id: targetId, text: targetWord });

          const targetChip = document.createElement('div');
          targetChip.className = 'chip word';
          targetChip.textContent = targetWord;
          targetChip.dataset.id = targetId;
          targetChip.style.background = '#4ade80'; // Green highlight for target completion
          wordsEl.appendChild(targetChip);

          pickNewTargetWord();
        }
      }
    }

    if (targetWord && wordText === targetWord) {
      const bonus = 30;
      newScore += bonus;
      log(`TARGET word completed directly! "${wordText}" (+${bonus} bonus)`);
      pickNewTargetWord();
    }

    score += newScore;
    scoreEl.textContent = score.toString();
    wordCountEl.textContent = words.length.toString();

    playWordSound();
    log(`WORD! "${wordText}" (+${newScore} pts)`);
    updateBestScore();
  }

  function tryMergeFragments() {
    if (fragments.length < 2) return;

    for (let i = 0; i < fragments.length; i++) {
      for (let j = 0; j < fragments.length; j++) {
        if (i === j) continue;
        const f1 = fragments[i];
        const f2 = fragments[j];
        const w1 = (f1.text + f2.text).toUpperCase();
        const w2 = (f2.text + f1.text).toUpperCase();

        if (WORD_DICTIONARY.includes(w1)) {
          formWordFromFragments([f1.id, f2.id], w1);
          return;
        }
        if (WORD_DICTIONARY.includes(w2)) {
          formWordFromFragments([f1.id, f2.id], w2);
          return;
        }
      }
    }
  }

  function gameLoop() {
    if (!running || gameOverFlag) return;
    const rect = gameArea.getBoundingClientRect();
    const bubbleSize = 58;

    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      b.y -= b.speed * 5;

      if (b.y < -bubbleSize) {
        if (b.el && b.el.parentNode) {
          b.el.parentNode.removeChild(b.el);
        }
        bubbles.splice(i, 1);
      } else {
        b.el.style.top = b.y + 'px';
      }
    }
  }

  function spawnLoop() {
    if (!running || gameOverFlag) return;
    const settings = DIFFICULTY_SETTINGS[currentDifficulty];
    if (bubbles.length < settings.bubbleCap && seededRandom() < settings.spawnChance) {
      spawnBubble();
    }
  }

  function timerLoop() {
    if (!running || gameOverFlag) return;
    if (!isFinite(timeLeft)) return;

    timeLeft -= 1;
    if (timeLeft < 0) timeLeft = 0;
    timeLeftEl.textContent = timeLeft.toString();

    if (timeLeft === 0) {
      triggerGameOver("Time's up");
    }
  }

  function triggerGameOver(reason) {
    if (gameOverFlag) return;
    gameOverFlag = true;
    running = false;
    overlayText.textContent = "Game Over – " + reason;
    overlay.classList.add('visible');
    log("Game over: " + reason);

    // Notify Swift in daily mode
    notifyGameComplete();
  }

  function startGame() {
    if (gameOverFlag) return;
    running = true;
    initAudio();
    overlay.classList.remove('visible');

    const mode = modeSelect.value;
    if (mode === 'timed') {
      if (!isFinite(timeLeft) || timeLeft === Infinity || timeLeft > TIMED_MODE_SECONDS) {
        timeLeft = TIMED_MODE_SECONDS;
      }
      timeLeftEl.textContent = timeLeft.toString();
    } else {
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
    }

    if (!gameInterval) {
      gameInterval = setInterval(gameLoop, 50);
    }
    if (!spawnInterval) {
      spawnInterval = setInterval(spawnLoop, 250);
    }
    if (!timerInterval) {
      timerInterval = setInterval(timerLoop, 1000);
    }

    log(`Game started (${mode} mode, ${currentDifficulty} difficulty).`);
  }

  function pauseGame() {
    if (gameOverFlag) return;
    running = false;
    log("Game paused.");
  }

  function restartGame() {
    if (gameInterval) clearInterval(gameInterval);
    if (spawnInterval) clearInterval(spawnInterval);
    if (timerInterval) clearInterval(timerInterval);
    gameInterval = null;
    spawnInterval = null;
    timerInterval = null;

    running = false;
    gameOverFlag = false;

    bubbles.forEach(b => {
      if (b.el && b.el.parentNode) b.el.parentNode.removeChild(b.el);
    });
    bubbles = [];
    selectedBubbles = [];
    fragments = [];
    words = [];
    score = 0;
    bubbleIdCounter = 0;

    scoreEl.textContent = "0";
    wordCountEl.textContent = "0";
    fragmentCountEl.textContent = "0";
    fragmentsEl.innerHTML = "";
    wordsEl.innerHTML = "";
    logEl.innerHTML = "";
    updatePickDisplay();

    const mode = modeSelect.value;
    if (mode === 'timed') {
      timeLeft = TIMED_MODE_SECONDS;
      timeLeftEl.textContent = timeLeft.toString();
    } else {
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
    }

    overlay.classList.remove('visible');
    initTargetWordPool(); // Shuffle target words for new game
    pickNewTargetWord();
    log("Game reset. Press Start.");
  }

  function applyTheme(theme) {
    currentTheme = theme;
    gameArea.classList.remove('theme-default','theme-social','theme-scientific','theme-animals');
    WORD_DICTIONARY = DICTIONARIES[theme].slice();
    initTargetWordPool(); // Re-shuffle for new theme
    switch (theme) {
      case 'social':
        gameArea.classList.add('theme-social');
        log("Theme: Social words.");
        break;
      case 'scientific':
        gameArea.classList.add('theme-scientific');
        log("Theme: Scientific words.");
        break;
      case 'animals':
        gameArea.classList.add('theme-animals');
        log("Theme: Animals.");
        break;
      default:
        gameArea.classList.add('theme-default');
        log("Theme: Default words.");
        break;
    }
    pickNewTargetWord();
  }

  function applyDifficulty(diff) {
    currentDifficulty = diff;
    log("Difficulty set to: " + diff);
  }

  function maybeShowTutorial() {
    // Never show tutorial in daily mode
    if (window.dailyMode) return;

    let seen = false;
    try {
      seen = localStorage.getItem('wordDriftSeenTutorial') === '1';
    } catch (e) {
      seen = false;
    }
    if (!seen) {
      tutorialOverlay.classList.add('visible');
    }
  }

  function markTutorialSeen() {
    try {
      localStorage.setItem('wordDriftSeenTutorial', '1');
    } catch (e) {}
  }

  tutorialClose.addEventListener('click', () => {
    tutorialOverlay.classList.remove('visible');
    markTutorialSeen();
  });

  btnStart.addEventListener('click', startGame);
  btnPause.addEventListener('click', pauseGame);
  btnRestart.addEventListener('click', restartGame);

  modeSelect.addEventListener('change', () => {
    const mode = modeSelect.value;
    if (mode === 'timed') {
      timeLeft = TIMED_MODE_SECONDS;
      timeLeftEl.textContent = timeLeft.toString();
      log("Mode: Timed (60s). Restart recommended.");
    } else if (mode === 'fragments') {
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
      log("Mode: Fragment Cap (" + FRAGMENT_LIMIT + ").");
    } else {
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
      log("Mode: Relax.");
    }
  });

  dictSelect.addEventListener('change', () => {
    applyTheme(dictSelect.value);
    restartGame();
  });

  difficultySelect.addEventListener('change', () => {
    applyDifficulty(difficultySelect.value);
  });

  // Init
  loadBestScore();
  applyTheme('default');
  applyDifficulty('normal');

  // Only run startup sequence if NOT waiting for daily seed from Swift
  if (!window.waitingForSeed) {
    restartGame();
    maybeShowTutorial();
  } else {
    console.log("⏳ Waiting for daily seed from Swift...");
  }
</script>
</body>
</html>

