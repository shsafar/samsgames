<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Word Drift – Bubble Prototype</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: Arial, sans-serif;
      background: #111;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    .game-wrapper {
      width: 900px;
      max-width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .title-bar {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .title-bar h1 {
      font-size: 1.4rem;
    }

    .subline {
      font-size: 0.8rem;
      opacity: 0.7;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
    }

    button {
      background: #28a8ff;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      font-size: 0.8rem;
      white-space: nowrap;
    }

    button:hover {
      background: #1b88d0;
    }

    select {
      background: #1b1d26;
      color: #f5f5f5;
      border-radius: 4px;
      border: 1px solid #3a405b;
      padding: 4px 6px;
      font-size: 0.8rem;
    }

    label {
      font-size: 0.8rem;
      opacity: 0.85;
    }

    .score-board {
      display: flex;
      gap: 16px;
      font-size: 0.9rem;
      opacity: 0.9;
      align-items: center;
      flex-wrap: wrap;
    }

    .score-board span {
      font-weight: bold;
    }

    .score-group {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .score-board .timer {
      margin-left: auto;
    }

    .target-display {
      font-size: 0.9rem;
    }

    .target-display span {
      font-weight: bold;
      color: #ffe45b;
    }

    .current-pick {
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    #pick-letters {
      display: inline-block;
      min-width: 24px;
      padding: 2px 8px;
      border-radius: 999px;
      background: #3a254f;
      border: 1px solid #915bff;
      text-align: center;
      font-weight: bold;
      font-size: 0.9rem;
      color: #ffeefc;
    }

    .game-area {
      position: relative;
      width: 100%;
      height: 420px;
      border-radius: 12px;
      overflow: hidden;
      background: radial-gradient(circle at top, #223a63, #050811);
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }

    .theme-default {
      background: radial-gradient(circle at top, #223a63, #050811);
    }
    .theme-science {
      background: radial-gradient(circle at top, #1f5c3a, #02140b);
    }
    .theme-dental {
      background: radial-gradient(circle at top, #c7f0ff, #2682b4);
    }
    .theme-physics {
      background: radial-gradient(circle at top, #4b2b70, #0a0217);
    }

    .overlay-message {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 1.4rem;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .overlay-message.visible {
      opacity: 1;
    }

    .overlay-message small {
      font-size: 0.9rem;
      margin-top: 6px;
      opacity: 0.85;
    }

    .bubble {
      position: absolute;
      width: 58px;
      height: 58px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffffff, #82d4ff);
      box-shadow: 0 0 10px rgba(130,212,255,0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.6rem;
      font-weight: bold;
      color: #00324f;
      border: 2px solid rgba(255,255,255,0.75);
      cursor: pointer;
      user-select: none;
      transition: transform 0.1s ease, box-shadow 0.1s ease, border-color 0.1s ease;
    }

    .bubble.selected {
      transform: scale(1.1);
      box-shadow: 0 0 15px rgba(255,255,255,1);
      border-color: #ffe45b;
    }

    /* Burst animation */
    .bubble.burst {
      animation: bubbleBurst 0.25s forwards;
    }

    @keyframes bubbleBurst {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      100% {
        transform: scale(1.6);
        opacity: 0;
      }
    }

    .bottom-panels {
      display: grid;
      grid-template-columns: 1.5fr 1.5fr 1fr;
      gap: 8px;
      font-size: 0.85rem;
    }

    .panel {
      background: #1b1d26;
      border-radius: 8px;
      padding: 6px;
      border: 1px solid #2e3244;
      overflow: hidden;
    }

    .panel h3 {
      font-size: 0.85rem;
      margin-bottom: 4px;
      opacity: 0.85;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-height: 56px;
      overflow-y: auto;
    }

    .chip {
      padding: 3px 7px;
      border-radius: 999px;
      background: #29324c;
      color: #f5f5f5;
      font-size: 0.8rem;
      border: 1px solid #3c4a6b;
      white-space: nowrap;
    }

    .chip.word {
      background: #21c178;
      border-color: #23e18b;
      color: #022516;
      font-weight: bold;
    }

    .log {
      font-size: 0.75rem;
      max-height: 56px;
      overflow-y: auto;
      line-height: 1.3;
    }

    .log-entry {
      opacity: 0.85;
    }

    .log-entry + .log-entry {
      margin-top: 2px;
    }

    /* Tutorial overlay */
    .tutorial-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .tutorial-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .tutorial-box {
      background: #1b1d26;
      border-radius: 12px;
      padding: 18px 20px;
      max-width: 420px;
      border: 1px solid #3a405b;
      box-shadow: 0 0 20px rgba(0,0,0,0.8);
    }

    .tutorial-box h2 {
      font-size: 1.2rem;
      margin-bottom: 8px;
    }

    .tutorial-box p {
      font-size: 0.85rem;
      opacity: 0.9;
      margin-bottom: 6px;
    }

    .tutorial-box ul {
      margin: 6px 0 12px;
      padding-left: 18px;
      font-size: 0.85rem;
      opacity: 0.9;
    }

    .tutorial-box li + li {
      margin-top: 4px;
    }

    .tutorial-footnote {
      font-size: 0.75rem;
      opacity: 0.7;
      margin-bottom: 10px;
    }

    .tutorial-actions {
      display: flex;
      justify-content: flex-end;
    }

    .tutorial-btn {
      background: #28a8ff;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      font-size: 0.85rem;
    }

    .tutorial-btn:hover {
      background: #1b88d0;
    }
  </style>
</head>
<body>
<div class="game-wrapper">

  <div class="top-bar">
    <div class="title-bar">
      <h1>Word Drift – Bubble Prototype</h1>
      <div class="subline">Tap two bubbles to create fragments. Fragments auto-merge into words.</div>
    </div>

    <div class="controls">
      <div>
        <label for="mode-select">Mode:</label>
        <select id="mode-select">
          <option value="relax">Relax</option>
          <option value="timed">Timed (60s)</option>
          <option value="fragments">Fragment Cap (12)</option>
        </select>
      </div>
      <div>
        <label for="difficulty-select">Difficulty:</label>
        <select id="difficulty-select">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </div>
      <div>
        <label for="dict-select">Theme:</label>
        <select id="dict-select">
          <option value="default">Default</option>
          <option value="science">Science</option>
          <option value="dental">Dental</option>
          <option value="physics">Physics</option>
        </select>
      </div>
      <button id="btn-start">Start</button>
      <button id="btn-pause">Pause</button>
      <button id="btn-restart">Restart</button>
    </div>
  </div>

  <div class="score-board">
    <div class="score-group">
      <div>Score: <span id="score">0</span></div>
      <div>Best: <span id="best-score">0</span></div>
      <div>Words: <span id="word-count">0</span></div>
      <div>Fragments: <span id="fragment-count">0</span></div>
    </div>
    <div class="target-display">
      Target: <span id="target-word">—</span>
    </div>
    <div class="current-pick">
      Pick:
      <span id="pick-letters">—</span>
    </div>
    <div class="timer">Time: <span id="time-left">∞</span></div>
  </div>

  <div id="game-area" class="game-area theme-default">
    <div id="overlay" class="overlay-message">
      <div id="overlay-text">Game Over</div>
      <small>Press Restart to play again.</small>
    </div>
  </div>

  <div class="bottom-panels">
    <div class="panel">
      <h3>Fragments</h3>
      <div id="fragments" class="chips"></div>
    </div>
    <div class="panel">
      <h3>Words Formed</h3>
      <div id="words" class="chips"></div>
    </div>
    <div class="panel">
      <h3>Log</h3>
      <div id="log" class="log"></div>
    </div>
  </div>
</div>

<!-- Tutorial overlay -->
<div id="tutorial-overlay" class="tutorial-overlay">
  <div class="tutorial-box">
    <h2>How to Play Word Drift</h2>
    <p>Quick basics so you can start playing in seconds:</p>
    <ul>
      <li><strong>Tap two bubbles</strong> to pop them into a letter fragment (like <em>AT</em> or <em>TO</em>).</li>
      <li>Fragments <strong>auto-merge into real words</strong> from the theme dictionary for points.</li>
      <li>Watch the <strong>TARGET word</strong> and modes at the top – forming the target gives a bonus.</li>
    </ul>
    <p class="tutorial-footnote">
      You can change <strong>Mode</strong>, <strong>Difficulty</strong>, and <strong>Theme</strong> anytime.  
      This tutorial only shows once on this device.
    </p>
    <div class="tutorial-actions">
      <button id="tutorial-close" class="tutorial-btn">Got it, let’s play</button>
    </div>
  </div>
</div>

<script>
  const gameArea = document.getElementById('game-area');
  const overlay = document.getElementById('overlay');
  const overlayText = document.getElementById('overlay-text');

  const scoreEl = document.getElementById('score');
  const bestScoreEl = document.getElementById('best-score');
  const wordCountEl = document.getElementById('word-count');
  const fragmentCountEl = document.getElementById('fragment-count');
  const fragmentsEl = document.getElementById('fragments');
  const wordsEl = document.getElementById('words');
  const logEl = document.getElementById('log');
  const timeLeftEl = document.getElementById('time-left');
  const targetWordEl = document.getElementById('target-word');
  const pickLettersEl = document.getElementById('pick-letters');

  const btnStart = document.getElementById('btn-start');
  const btnPause = document.getElementById('btn-pause');
  const btnRestart = document.getElementById('btn-restart');
  const modeSelect = document.getElementById('mode-select');
  const dictSelect = document.getElementById('dict-select');
  const difficultySelect = document.getElementById('difficulty-select');

  const tutorialOverlay = document.getElementById('tutorial-overlay');
  const tutorialClose = document.getElementById('tutorial-close');

  const LETTERS = "AABCDEEFGHIIJKLMNOOPQRSTUUVWXYZ";

  const DICTIONARIES = {
    default: [
      "AT","IN","ON","TO","IT","OF","UP","NO","GO","AS",
      "ATOM","SHOW","COOK","STAR","TREE","BOOK","GAME","WORD",
      "TIME","BRAIN","PLAY","NOTE","WAVE","CODE","LOVE"
    ],
    science: [
      "AT","IN","ON","TO","UP","NO",
      "ATOM","CELL","GENE","WAVE","LIGHT","CORE","ION","MASS","FIELD"
    ],
    dental: [
      "AT","IN","ON","TO","UP","NO",
      "TOOTH","GUMS","ROOT","CROWN","NERVE","SMILE","BRACE","ENAMEL","MOLAR","FLOSS"
    ],
    physics: [
      "AT","IN","ON","TO","UP","NO",
      "FORCE","MASS","WAVE","LIGHT","QUANTUM","GRAVITY","FIELD","CORE","STRING"
    ]
  };

  const DIFFICULTY_SETTINGS = {
    easy:   { speedMin: 0.3, speedMax: 0.6, spawnChance: 0.55, bubbleCap: 10 },
    normal: { speedMin: 0.4, speedMax: 0.8, spawnChance: 0.8,  bubbleCap: 12 },
    hard:   { speedMin: 0.6, speedMax: 1.1, spawnChance: 1.0,  bubbleCap: 14 }
  };

  let currentDifficulty = 'normal';
  let WORD_DICTIONARY = DICTIONARIES.default.slice();
  let currentTheme = 'default';
  let targetWord = null;

  const FRAGMENT_LIMIT = 12;
  const TIMED_MODE_SECONDS = 60;

  let bubbles = [];
  let bubbleIdCounter = 0;
  let gameInterval = null;
  let spawnInterval = null;
  let timerInterval = null;
  let running = false;
  let gameOverFlag = false;

  let selectedBubbles = [];
  let fragments = [];
  let words = [];
  let score = 0;
  let bestScore = 0;
  let timeLeft = Infinity;

  // DAILY MODE INTEGRATION
  window.dailyMode = false;
  let dailySeed = null;
  let seededRandom = Math.random; // Default to Math.random

  // Seeded random number generator (LCG algorithm)
  function createSeededRandom(seed) {
    let state = seed % 2147483647;
    if (state <= 0) state += 2147483646;

    return function() {
      state = (state * 16807) % 2147483647;
      return (state - 1) / 2147483646;
    };
  }

  // Set seed for daily mode
  window.setSeed = function(seed) {
    dailySeed = seed;
    seededRandom = createSeededRandom(seed);
    console.log("✅ Seed set for daily mode:", seed);
  };

  // Start daily game (called from Swift)
  window.startDailyGame = function() {
    window.dailyMode = true;
    console.log("✅ Starting daily game mode");

    // Hide controls in daily mode
    document.getElementById('btn-start').style.display = 'none';
    document.getElementById('btn-pause').style.display = 'none';
    document.getElementById('btn-restart').style.display = 'none';
    document.querySelector('label[for="mode-select"]').parentElement.style.display = 'none';
    document.querySelector('label[for="difficulty-select"]').parentElement.style.display = 'none';
    document.querySelector('label[for="dict-select"]').parentElement.style.display = 'none';

    // Set to fragment cap mode with 12 fragments
    modeSelect.value = 'fragments';
    timeLeft = Infinity;
    timeLeftEl.textContent = "∞";

    // Start the game automatically
    restartGame();
    startGame();
  };

  // Notify Swift when game completes
  function notifyGameComplete() {
    if (window.dailyMode && window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.gameCompleted) {
      window.webkit.messageHandlers.gameCompleted.postMessage({
        score: score
      });
      console.log("✅ Daily puzzle completed - notified Swift with score:", score);
    }
  }

  // SOUND
  let audioCtx = null;
  function initAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  function playBeep(freq, duration, type = "sine", volume = 0.2) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    gain.gain.value = volume;

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    osc.start(now);
    osc.stop(now + duration);
  }

  function playPopSound() {
    playBeep(600, 0.07, "square", 0.15);
  }

  function playWordSound() {
    playBeep(800, 0.09, "triangle", 0.2);
    setTimeout(() => playBeep(1200, 0.09, "triangle", 0.2), 110);
  }

  function log(message) {
    const div = document.createElement('div');
    div.className = 'log-entry';
    div.textContent = message;
    logEl.prepend(div);
    const maxLines = 15;
    while (logEl.children.length > maxLines) {
      logEl.removeChild(logEl.lastChild);
    }
  }

  function randomLetter() {
    return LETTERS[Math.floor(seededRandom() * LETTERS.length)];
  }

  // High score
  function loadBestScore() {
    try {
      const stored = localStorage.getItem('wordDriftHighScore');
      bestScore = stored !== null ? (parseInt(stored, 10) || 0) : 0;
    } catch (e) {
      bestScore = 0;
    }
    bestScoreEl.textContent = bestScore.toString();
  }

  function updateBestScore() {
    if (score > bestScore) {
      bestScore = score;
      bestScoreEl.textContent = bestScore.toString();
      try {
        localStorage.setItem('wordDriftHighScore', String(bestScore));
      } catch (e) {}
      log("New high score! " + bestScore);
    }
  }

  // Target word
  function pickNewTargetWord() {
    const list = DICTIONARIES[currentTheme] || [];
    const candidates = list.filter(w => w.length >= 4);
    const pool = candidates.length > 0 ? candidates : list;
    if (pool.length === 0) {
      targetWord = null;
      targetWordEl.textContent = "—";
      return;
    }
    targetWord = pool[Math.floor(seededRandom() * pool.length)];
    targetWordEl.textContent = targetWord;
    log("New target word: " + targetWord);
  }

  // Staging display
  function updatePickDisplay() {
    if (selectedBubbles.length === 0) {
      pickLettersEl.textContent = "—";
      return;
    }
    const txt = selectedBubbles.map(b => b.letter).join('');
    pickLettersEl.textContent = txt;
  }

  function spawnBubble() {
    const rect = gameArea.getBoundingClientRect();
    const bubbleSize = 58;
    const settings = DIFFICULTY_SETTINGS[currentDifficulty];

    const x = seededRandom() * (rect.width - bubbleSize);
    const y = rect.height;
    const speed = settings.speedMin + seededRandom() * (settings.speedMax - settings.speedMin);

    const letter = randomLetter();
    const id = bubbleIdCounter++;

    const el = document.createElement('div');
    el.className = 'bubble';
    el.textContent = letter;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.dataset.id = id;
    el.dataset.letter = letter;

    el.addEventListener('click', () => onBubbleClick(id));

    gameArea.appendChild(el);

    bubbles.push({ id, x, y, speed, letter, el });
  }

  function onBubbleClick(id) {
    if (!running || gameOverFlag) return;
    initAudio();

    const bubble = bubbles.find(b => b.id === id);
    if (!bubble) return;

    const alreadySelected = selectedBubbles.find(b => b.id === id);

    if (alreadySelected) {
      bubble.el.classList.remove('selected');
      selectedBubbles = selectedBubbles.filter(b => b.id !== id);
      updatePickDisplay();
      return;
    }

    if (selectedBubbles.length >= 2) {
      selectedBubbles.forEach(b => b.el.classList.remove('selected'));
      selectedBubbles = [];
    }

    bubble.el.classList.add('selected');
    selectedBubbles.push(bubble);
    updatePickDisplay();

    if (selectedBubbles.length === 2) {
      createFragmentFromSelection();
    }
  }

  // Helper: burst + remove both visually and from list
  function burstAndRemoveBubble(bubble) {
    if (!bubble || !bubble.el) return;
    const el = bubble.el;

    // stop gameLoop from moving it
    bubbles = bubbles.filter(x => x.id !== bubble.id);

    el.classList.remove('selected');
    el.classList.add('burst');

    el.addEventListener('animationend', () => {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, { once: true });
  }

  // Non-animated removal (for off-screen, restart, etc.)
  function removeBubblePlain(id) {
    const index = bubbles.findIndex(b => b.id === id);
    if (index === -1) return;
    const bubble = bubbles[index];
    bubbles.splice(index, 1);
    if (bubble.el && bubble.el.parentNode) {
      bubble.el.parentNode.removeChild(bubble.el);
    }
  }

  function createFragmentFromSelection() {
    if (selectedBubbles.length !== 2) return;
    const [b1, b2] = selectedBubbles;
    const fragmentText = (b1.letter + b2.letter).toUpperCase();

    burstAndRemoveBubble(b1);
    burstAndRemoveBubble(b2);

    selectedBubbles = [];
    updatePickDisplay();

    addFragment(fragmentText);
    playPopSound();
  }

  function addFragment(text) {
    const id = Date.now() + ":" + Math.random().toString(16).slice(2);
    fragments.push({ id, text });

    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent = text;
    chip.dataset.id = id;
    fragmentsEl.appendChild(chip);

    fragmentCountEl.textContent = fragments.length.toString();
    log("Fragment: " + text);

    const isDictWord = WORD_DICTIONARY.includes(text);
    const isPrefixOfTarget =
      !!(targetWord &&
         targetWord.length > text.length &&
         targetWord.startsWith(text));

    // If it's a dictionary word but also a strict prefix of target,
    // keep as fragment so it can grow into the target word.
    if (isDictWord && !isPrefixOfTarget) {
      formWordFromFragments([id], text);
    } else {
      tryMergeFragments();
    }

    if (modeSelect.value === 'fragments' && fragments.length > FRAGMENT_LIMIT) {
      triggerGameOver("Too many fragments (> " + FRAGMENT_LIMIT + ")");
    }
  }

  function formWordFromFragments(fragmentIds, wordText) {
    fragmentIds.forEach(fid => {
      const idx = fragments.findIndex(f => f.id === fid);
      if (idx !== -1) fragments.splice(idx, 1);

      const chip = fragmentsEl.querySelector(`.chip[data-id="${fid}"]`);
      if (chip) chip.remove();
    });

    fragmentCountEl.textContent = fragments.length.toString();

    const id = Date.now() + ":" + Math.random().toString(16).slice(2);
    words.push({ id, text: wordText });

    const chip = document.createElement('div');
    chip.className = 'chip word';
    chip.textContent = wordText;
    chip.dataset.id = id;
    wordsEl.appendChild(chip);

    const base = 10;
    const lenBonus = Math.max(0, wordText.length - 2) * 5;
    let newScore = base + lenBonus;

    if (targetWord && wordText === targetWord) {
      const bonus = 30;
      newScore += bonus;
      log(`TARGET word completed! "${wordText}" (+${bonus} bonus)`);
      pickNewTargetWord();
    }

    score += newScore;
    scoreEl.textContent = score.toString();
    wordCountEl.textContent = words.length.toString();

    playWordSound();
    log(`WORD! "${wordText}" (+${newScore} pts)`);
    updateBestScore();
  }

  function tryMergeFragments() {
    if (fragments.length < 2) return;

    for (let i = 0; i < fragments.length; i++) {
      for (let j = 0; j < fragments.length; j++) {
        if (i === j) continue;
        const f1 = fragments[i];
        const f2 = fragments[j];
        const w1 = (f1.text + f2.text).toUpperCase();
        const w2 = (f2.text + f1.text).toUpperCase();

        if (WORD_DICTIONARY.includes(w1)) {
          formWordFromFragments([f1.id, f2.id], w1);
          return;
        }
        if (WORD_DICTIONARY.includes(w2)) {
          formWordFromFragments([f1.id, f2.id], w2);
          return;
        }
      }
    }
  }

  function gameLoop() {
    if (!running || gameOverFlag) return;
    const rect = gameArea.getBoundingClientRect();
    const bubbleSize = 58;

    for (let i = bubbles.length - 1; i >= 0; i--) {
      const b = bubbles[i];
      b.y -= b.speed * 5;

      if (b.y < -bubbleSize) {
        if (b.el && b.el.parentNode) {
          b.el.parentNode.removeChild(b.el);
        }
        bubbles.splice(i, 1);
      } else {
        b.el.style.top = b.y + 'px';
      }
    }
  }

  function spawnLoop() {
    if (!running || gameOverFlag) return;
    const settings = DIFFICULTY_SETTINGS[currentDifficulty];
    if (bubbles.length < settings.bubbleCap && seededRandom() < settings.spawnChance) {
      spawnBubble();
    }
  }

  function timerLoop() {
    if (!running || gameOverFlag) return;
    if (!isFinite(timeLeft)) return;

    timeLeft -= 1;
    if (timeLeft < 0) timeLeft = 0;
    timeLeftEl.textContent = timeLeft.toString();

    if (timeLeft === 0) {
      triggerGameOver("Time's up");
    }
  }

  function triggerGameOver(reason) {
    if (gameOverFlag) return;
    gameOverFlag = true;
    running = false;
    overlayText.textContent = "Game Over – " + reason;
    overlay.classList.add('visible');
    log("Game over: " + reason);

    // Notify Swift in daily mode
    notifyGameComplete();
  }

  function startGame() {
    if (gameOverFlag) return;
    running = true;
    initAudio();
    overlay.classList.remove('visible');

    const mode = modeSelect.value;
    if (mode === 'timed') {
      if (!isFinite(timeLeft) || timeLeft === Infinity || timeLeft > TIMED_MODE_SECONDS) {
        timeLeft = TIMED_MODE_SECONDS;
      }
      timeLeftEl.textContent = timeLeft.toString();
    } else {
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
    }

    if (!gameInterval) {
      gameInterval = setInterval(gameLoop, 50);
    }
    if (!spawnInterval) {
      spawnInterval = setInterval(spawnLoop, 250);
    }
    if (!timerInterval) {
      timerInterval = setInterval(timerLoop, 1000);
    }

    log(`Game started (${mode} mode, ${currentDifficulty} difficulty).`);
  }

  function pauseGame() {
    if (gameOverFlag) return;
    running = false;
    log("Game paused.");
  }

  function restartGame() {
    if (gameInterval) clearInterval(gameInterval);
    if (spawnInterval) clearInterval(spawnInterval);
    if (timerInterval) clearInterval(timerInterval);
    gameInterval = null;
    spawnInterval = null;
    timerInterval = null;

    running = false;
    gameOverFlag = false;

    bubbles.forEach(b => {
      if (b.el && b.el.parentNode) b.el.parentNode.removeChild(b.el);
    });
    bubbles = [];
    selectedBubbles = [];
    fragments = [];
    words = [];
    score = 0;
    bubbleIdCounter = 0;

    scoreEl.textContent = "0";
    wordCountEl.textContent = "0";
    fragmentCountEl.textContent = "0";
    fragmentsEl.innerHTML = "";
    wordsEl.innerHTML = "";
    logEl.innerHTML = "";
    updatePickDisplay();

    const mode = modeSelect.value;
    if (mode === 'timed') {
      timeLeft = TIMED_MODE_SECONDS;
      timeLeftEl.textContent = timeLeft.toString();
    } else {
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
    }

    overlay.classList.remove('visible');
    pickNewTargetWord();
    log("Game reset. Press Start.");
  }

  function applyTheme(theme) {
    currentTheme = theme;
    gameArea.classList.remove('theme-default','theme-science','theme-dental','theme-physics');
    WORD_DICTIONARY = DICTIONARIES[theme].slice();
    switch (theme) {
      case 'science':
        gameArea.classList.add('theme-science');
        log("Theme: Science words.");
        break;
      case 'dental':
        gameArea.classList.add('theme-dental');
        log("Theme: Dental words.");
        break;
      case 'physics':
        gameArea.classList.add('theme-physics');
        log("Theme: Physics words.");
        break;
      default:
        gameArea.classList.add('theme-default');
        log("Theme: Default words.");
        break;
    }
    pickNewTargetWord();
  }

  function applyDifficulty(diff) {
    currentDifficulty = diff;
    log("Difficulty set to: " + diff);
  }

  function maybeShowTutorial() {
    let seen = false;
    try {
      seen = localStorage.getItem('wordDriftSeenTutorial') === '1';
    } catch (e) {
      seen = false;
    }
    if (!seen) {
      tutorialOverlay.classList.add('visible');
    }
  }

  function markTutorialSeen() {
    try {
      localStorage.setItem('wordDriftSeenTutorial', '1');
    } catch (e) {}
  }

  tutorialClose.addEventListener('click', () => {
    tutorialOverlay.classList.remove('visible');
    markTutorialSeen();
  });

  btnStart.addEventListener('click', startGame);
  btnPause.addEventListener('click', pauseGame);
  btnRestart.addEventListener('click', restartGame);

  modeSelect.addEventListener('change', () => {
    const mode = modeSelect.value;
    if (mode === 'timed') {
      timeLeft = TIMED_MODE_SECONDS;
      timeLeftEl.textContent = timeLeft.toString();
      log("Mode: Timed (60s). Restart recommended.");
    } else if (mode === 'fragments') {
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
      log("Mode: Fragment Cap (" + FRAGMENT_LIMIT + ").");
    } else {
      timeLeft = Infinity;
      timeLeftEl.textContent = "∞";
      log("Mode: Relax.");
    }
  });

  dictSelect.addEventListener('change', () => {
    applyTheme(dictSelect.value);
    restartGame();
  });

  difficultySelect.addEventListener('change', () => {
    applyDifficulty(difficultySelect.value);
  });

  // Init
  loadBestScore();
  applyTheme('default');
  applyDifficulty('normal');
  restartGame();
  maybeShowTutorial();
</script>
</body>
</html>

